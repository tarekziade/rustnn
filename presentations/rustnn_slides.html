<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>rustnn_slides</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.5.0/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.5.0/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.5.0/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="reveal-overrides.css"/>
  <script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";

  mermaid.initialize({
    startOnLoad: false,
    theme: "base",
    themeVariables: {
      fontSize: "12px",
      textColor: "#222222",
      lineColor: "#333333"
    },
    flowchart: {
      useMaxWidth: true,
      htmlLabels: true,
      nodeSpacing: 50,
      rankSpacing: 60
    }
  });

  /* Convert Pandoc's <pre><code class="mermaid">...</code></pre> into <div class="mermaid">...</div> */
  function normalizeMermaidBlocks(root = document) {
    const candidates = Array.from(root.querySelectorAll('pre.mermaid, pre > code.mermaid'));
    const pres = candidates.map(n => n.tagName.toLowerCase() === 'code' ? n.parentElement : n)
                          .filter(Boolean);

    pres.forEach(pre => {
      // if already converted, skip
      if (pre.dataset.mermaidNormalized) return;
      const code = pre.querySelector('code');
      const txt = code ? code.textContent : pre.textContent;
      const div = document.createElement('div');
      div.className = 'mermaid';
      div.textContent = (txt || '').trim();
      pre.parentNode.replaceChild(div, pre);
      // mark original as normalized (for safety if re-run)
      div.dataset.mermaidNormalized = "1";
    });
  }

  /* Make injected SVGs responsive and remove tiny width/height */
  function fixRenderedSVGs(root = document) {
    const svgEls = Array.from(root.querySelectorAll('.mermaid svg'));
    svgEls.forEach(svg => {
      try {
        if (svg.hasAttribute('width')) svg.removeAttribute('width');
        if (svg.hasAttribute('height')) svg.removeAttribute('height');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', 'auto');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.style.display = 'block';
      } catch (e) {
        console.warn('mermaid: svg fix failed', e);
      }
    });
  }

  /* Render only mermaid blocks inside a given slide (or whole doc if no slide given).
     Uses a data flag to avoid double-rendering. */
  async function renderMermaidIn(root) {
    normalizeMermaidBlocks(root);

    const mermaids = Array.from((root.querySelectorAll ? root.querySelectorAll('.mermaid') : []))
                          .filter(el => !el.dataset.mermaidRendered);

    if (mermaids.length === 0) return;

    // If mermaid.run() exists prefer it; otherwise use init or mermaidAPI fallback.
    try {
      if (typeof mermaid.run === 'function') {
        // mermaid.run() will render all .mermaid nodes in document; we call it once for performance
        // but mark only those inside our root after render.
        mermaid.run();
      } else if (typeof mermaid.init === 'function') {
        mermaid.init(undefined, mermaids);
      } else if (mermaid.mermaidAPI && typeof mermaid.mermaidAPI.render === 'function') {
        // fallback: render each entry individually
        for (let i = 0; i < mermaids.length; i++) {
          const el = mermaids[i];
          const id = 'mermaid-' + i + '-' + Date.now();
          const txt = el.textContent || '';
          // mermaidAPI.render returns svg string via callback
          // we wrap into a Promise to await sequentially
          await new Promise((resolve) => {
            mermaid.mermaidAPI.render(id, txt, (svgCode) => {
              el.innerHTML = svgCode;
              resolve();
            }, el);
          });
        }
      }
      // small delay to let renderer inject SVGs, then fix them
      setTimeout(() => {
        fixRenderedSVGs(root);
        // mark rendered nodes so we don't re-render
        Array.from(root.querySelectorAll('.mermaid')).forEach(el => el.dataset.mermaidRendered = "1");
      }, 40);
      // another pass later for slow engines
      setTimeout(() => {
        fixRenderedSVGs(root);
        Array.from(root.querySelectorAll('.mermaid')).forEach(el => el.dataset.mermaidRendered = "1");
      }, 300);
    } catch (err) {
      console.error('Mermaid render error:', err);
    }
  }

  /* Helper: render the currently active slide (fast) */
  function renderCurrentSlide() {
    const current = (window.Reveal && typeof Reveal.getCurrentSlide === 'function')
      ? Reveal.getCurrentSlide()
      : document.querySelector('.slides section.present');

    if (current) {
      renderMermaidIn(current);
    } else {
      // fallback: render entire document
      renderMermaidIn(document);
    }
  }

  /* Attach Reveal event listeners and initial render */
  document.addEventListener('DOMContentLoaded', () => {
    // If Reveal exists, render on ready + slidechanged + fragmentshown + overviewhidden
    if (window.Reveal && typeof Reveal.on === 'function') {
      Reveal.on('ready', () => {
        // render first visible slide
        renderCurrentSlide();
        // also render any other slides that may be visible (fragments / vertical)
        // render whole document once to ensure diagrams in speaker notes etc. are available
        renderMermaidIn(document);
      });

      Reveal.on('slidechanged', (event) => {
        // event.currentSlide is the newly active slide
        if (event && event.currentSlide) {
          renderMermaidIn(event.currentSlide);
        } else {
          renderCurrentSlide();
        }
      });

      // fragments may introduce new mermaid blocks; render when fragments become visible
      Reveal.on('fragmentshown', (event) => {
        const frag = event && event.fragment ? event.fragment : null;
        if (frag) renderMermaidIn(frag.closest('section') || frag);
      });

      // when exiting overview, render current slide (some browsers delay)
      Reveal.on('overviewhidden', () => {
        renderCurrentSlide();
      });
    } else {
      // no Reveal: render all mermaid blocks on DOM load
      renderMermaidIn(document);
    }

    // As an additional safety: observe the document for new pre/code insertion (e.g., async content)
    const mo = new MutationObserver(mutations => {
      let found = false;
      for (const m of mutations) {
        if (m.addedNodes && m.addedNodes.length) {
          m.addedNodes.forEach(n => {
            if (n.nodeType === 1 && (n.matches('pre.mermaid') || n.querySelector && n.querySelector('code.mermaid'))) {
              found = true;
            }
          });
        }
      }
      if (found) {
        // normalize + render only for currently visible slide to be safe
        renderCurrentSlide();
      }
    });
    mo.observe(document.body, { childList: true, subtree: true });
  });
  </script>
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section class="slide level2">

<p><img src="https://raw.githubusercontent.com/tarekziade/rustnn/refs/heads/main/logo/rustnn.png"
     alt="rustnn logo"
     class="title-logo centered" /></p>
</section>
<section id="rustnn-rust-implementation-of-webnn" class="slide level2">
<h2>RustNN: Rust implementation of WebNN</h2>
<div>
<p>Tarek ZiadÃ©, Mozilla</p>
</div>
<div>
<p>Thursday Dec 18</p>
</div>
</section>
<section id="what-is-rustnn" class="slide level2">
<h2>What is rustnn?</h2>
<ul>
<li>An <strong>independent Rust implementation of the W3C WebNN
API</strong>.</li>
<li>Exposes a thin Python API (PyWebNN) similar to the JS API.</li>
<li>Built with Firefox integration as a primary target, but usable
outside browsers.</li>
</ul>
</section>
<section id="motivation" class="slide level2">
<h2>Motivation</h2>
<ul>
<li>We want to add WebNN support in Firefox.</li>
<li>Alternatives
<ul>
<li>Chromiumâ€™s implementation is Blink-dependent.</li>
<li><code>webnn-native</code> is stalled (2 years) and lacks modern
backend support.</li>
</ul></li>
<li>Rust is the natural choice for new Gecko components.</li>
<li>Python layer widens ML community reach.</li>
</ul>
</section>
<section id="design-goals" class="slide level2">
<h2>Design goals</h2>
<ul>
<li><strong>Strict spec interpretation</strong> â€” inputs are validated
and shapes computed exactly as defined by the WebNN spec.</li>
<li><strong>Backend independence</strong> â€” WebNN graph semantics are
decoupled from execution backends.</li>
<li><strong>Early error detection</strong> â€” invalid graphs rejected
before backend lowering.</li>
<li><strong>Testability</strong> â€” architecture designed to support WPT
ingestion and differential testing.</li>
<li><strong>Not just for browsers</strong> â€” Standalone rust lib, Python
bindings broaden WebNN reach in ML communities.</li>
</ul>
</section>
<section id="high-level-architecture" class="slide level2">
<h2>High-level architecture</h2>
<pre class="mermaid"><code>flowchart TD
  RustNN[&quot;RustNN&quot;]

  WebNNGraph[&quot;WebNN Graph&quot;]
  Executors[&quot;Executors&quot;]

  Converter[&quot;Converter&quot;]

  ONNXRuntime[&quot;onnx runtime&quot;]
  CoreMLExec[&quot;CoreML&quot;]
  TensorRT[&quot;TensorRT&quot;]

  ONNXGraph[&quot;ONNX Graph&quot;]
  CoreMLGraph[&quot;CoreML Graph&quot;]

  RustNN --&gt; WebNNGraph
  RustNN --&gt; Executors

  WebNNGraph --&gt; Converter
  Converter --&gt; ONNXGraph
  Converter --&gt; CoreMLGraph

  Executors --&gt; ONNXRuntime
  Executors --&gt; CoreMLExec
  Executors --&gt; TensorRT</code></pre>
</section>
<section id="simple-and-pluggable-rust-code-base" class="slide level2">
<h2>Simple and Pluggable Rust code base</h2>
<ul>
<li><code>src/graph.rs</code> â€” core graph structures and immutability
guarantees</li>
<li><code>src/validator.rs</code> â€” WebNN spec validation rules</li>
<li><code>src/shape_inference.rs</code> â€” static shape computation</li>
<li><code>src/converters/</code> â€” lowering to ONNX / CoreML graph</li>
<li><code>src/executors/</code> â€” backend execution adapters (ONNX
Runtime, CoreML, TensorRT)</li>
</ul>
</section>
<section id="minimal-python-example-pywebnn" class="slide level2">
<h2>Minimal Python example (PyWebNN)</h2>
<pre><code>import webnn
import numpy as np

# Create ML context with device hints
ml = webnn.ML()
context = ml.create_context(accelerated=False)  # CPU execution
builder = context.create_graph_builder()

# Build a simple graph: output = relu(x + y)
x = builder.input(&quot;x&quot;, [2, 3], &quot;float32&quot;)
y = builder.input(&quot;y&quot;, [2, 3], &quot;float32&quot;)
z = builder.add(x, y)
output = builder.relu(z)

# Compile the graph
graph = builder.build({&quot;output&quot;: output})

# Execute with real data
x_data = np.array([[1, -2, 3], [4, -5, 6]], dtype=np.float32)
y_data = np.array([[-1, 2, -3], [-4, 5, -6]], dtype=np.float32)
results = context.compute(graph, {&quot;x&quot;: x_data, &quot;y&quot;: y_data})

print(results[&quot;output&quot;])</code></pre>
<ul>
<li>Mirrors WebNN API structure (context â†’ builder â†’ graph).</li>
<li>Validation and shape inference happen at <code>build()</code>
time.</li>
<li>Backend lowering happens at <code>compute()</code> time.</li>
</ul>
</section>
<section id="minimal-rust-example" class="slide level2">
<h2>Minimal Rust example</h2>
<pre><code>use rustnn::graph::GraphBuilder;
use rustnn::types::{TensorDesc, DataType};
use rustnn::context::Context;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // execution context (backend selection happens later)
    let ctx = Context::default();
    let mut builder = GraphBuilder::new(&amp;ctx);

    // input tensor description
    let x = builder.input(
        &quot;x&quot;,
        TensorDesc::new(DataType::Float32, vec![1, 3]),
    )?;

    // y = relu(x)
    let y = builder.relu(&amp;x)?;

    // build immutable graph
    let graph = builder.build(vec![(&quot;y&quot;, y)])?;

    // execute (backend chosen internally)
    let result = graph.compute(vec![(&quot;x&quot;, vec![1.0f32, -2.0, 3.0])])?;

    println!(&quot;{:?}&quot;, result[&quot;y&quot;]);
    Ok(())
}</code></pre>
<ul>
<li>Same conceptual phases as Python: context â†’ builder â†’ graph â†’
compute.</li>
<li>Graph is validated and shape-inferred before execution.</li>
<li>Execution backend is selected at compute time.</li>
</ul>
</section>
<section id="firefox-support" class="slide level2">
<h2>Firefox support</h2>
<pre class="mermaid"><code>flowchart TB
  WebAPI[&quot;WebNN WebIDL JS API&quot;]
  Gecko[&quot;Gecko WebNN C++&quot;]
  FFI[&quot;FFI bridge&quot;]
  Core[&quot;third_party/rust/rustnn&quot;]

  WebAPI --&gt; Gecko
  Gecko --&gt; FFI
  FFI --&gt; Core</code></pre>
<ul>
<li>Classical WebIDL for JS layer</li>
<li>cbindgen for bridging rustnn to C++</li>
<li>rustnn centralizes spec logic outside Gecko.</li>
<li>Enables faster iteration and clearer separation of concerns.</li>
</ul>
</section>
<section id="screencast-demo" class="slide level2">
<h2>Screencast demo</h2>
<video controls autoplay loop muted style="max-width: 100%; height: auto;">
<source src="https://cotedorclassicjuniors.fr/webnn-demo.mov" type="video/quicktime">
<p>Your browser does not support the video tag. </video></p>
</section>
<section id="implementation-status-summary" class="slide level2">
<h2>Implementation status â€” Summary</h2>
<ul>
<li><p><strong>85 WebNN operations implemented</strong> (~89% of current
spec).</p></li>
<li><p>All implemented ops support:</p>
<ul>
<li>validation</li>
<li>shape inference</li>
<li>ONNX, CoreML lowering</li>
<li>ONNX, CoreML (partial), TensorRT (experimental) execution</li>
</ul></li>
<li><p>Remaining gaps are tracked.</p></li>
</ul>
</section>
<section id="implementation-status-gaps" class="slide level2">
<h2>Implementation status â€” Gaps</h2>
<ul>
<li><p><strong>RNN family (<code>lstm</code>, <code>gru</code>,
<code>rnn</code>)</strong> â€” deferred</p>
<ul>
<li>complex semantics</li>
<li>backend inconsistencies</li>
<li>open questions in spec text</li>
</ul></li>
<li><p>A small number of ops partially implemented where backend support
diverges.</p></li>
<li><p>CoreML partially implemented (Float16 ðŸ˜«).</p></li>
<li><p>Firefox patch POC quality (IPC layer missing).</p></li>
</ul>
</section>
<section id="wpt-conformance-testing" class="slide level2">
<h2>WPT &amp; conformance testing</h2>
<ul>
<li>WPT WebNN conformance and validation tests converted into Python
tests.</li>
<li>ONNX backend: <strong>1350 tests passing</strong> for supported
ops.</li>
<li>CoreML backend:
<ul>
<li>known executor bugs cause temporary skips.</li>
<li><strong>129 tests skipped</strong> due to architectural or
spec-related limitations (documented).</li>
</ul></li>
</ul>
</section>
<section id="next-steps" class="slide level2">
<h2>Next steps</h2>
<ol type="1">
<li>Finish WPT data conversion for remaining ops.</li>
<li>Implement more demos.</li>
<li>Finish TensortRT execution support</li>
<li>Work on performances</li>
<li>Improve documentation</li>
</ol>
</section>
<section id="thanks-questions" class="slide level2">
<h2>Thanks!! Questions ?</h2>
<ul>
<li>Repo: <a
href="https://github.com/tarekziade/rustnn">https://github.com/tarekziade/rustnn</a></li>
<li>Docs: <a
href="https://blog.ziade.org/rustnn/">https://blog.ziade.org/rustnn</a></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@4.5.0/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@4.5.0/plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@4.5.0/plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@4.5.0/plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 720,

        // Factor of the display size that should remain empty around the content
        margin: 0.06,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
